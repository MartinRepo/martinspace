---
title: "算法"
date: 2023-02-05T08:42:27Z
lastmod: 2023-02-16T07:23:32Z
draft: false
author: ["Martin"]
tags: 
- Algorithm
description: ""
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
comments: true
showToc: true # 显示目录
TocOpen: false # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: ""
    caption: ""
    alt: ""
    relative: false
mermaid: true
---
# 时间复杂度和online algorithm (W1)
在线算法指的是，算法必须在输入数据不是完全可知的情况下，完成相应的计算并输出计算结果。

与之对应的是离线算法，它充分利用了输入数据之间完整的关联特性，即算法运行前所有输入数据均是已知的。

竞争分析针对的是在线算法，已知一个在线算法A，S是问题的一个变量输入序列，用cost(A, S)记录算法A应对S所产生的成本，用cost(OPT, S)记录最优离线算法应对S所产生的费用。若对于任意S都有```cost(A, S)<a*cost(OPT, S)```，则A是一个a-竞争算法。
 
# BST和其他搜索树 (W2)

## 链表
双向链表，如下图所示，每个节点都有一个前继(prev)和一个后驱(next)。
![linkedlist](/img/linkedlist.jpg)

双向链表的几个常用方法
```java
replaceElement(p,e) // p - position, e - element.
swapElements(p,q) // p,q - positions.
insertFirst(e) // e - element.
insertLast(e) // e - element.
insertBefore(p,e) // p - position, e - element.
insertAfter(p,e) // p - position, e - element.
remove(p) // p - position.
```
介绍其中一个方法：insertBefore()

技巧：要确保每个节点的前后两个指针都有连接，如上图所示。
```java
    s.prev = p;          /* 把 p 赋值给 s 的前驱 */
    s.next = p.next;     /* 把 p->next 赋值给 s 的后继 */
    (p.next).prev = s;    /* 把 s 赋值给 p->next 的前驱 */
    p.next = s;           /* 把 s 赋值给 p 的后继 */
```
List更新的复杂度分析（remove和insert）
- 如果元素p的位置已知，则复杂度为O(1)
- 如果只知道list的头，则复杂度为O(p)，因为需要遍历list来找到p

## 二分查找（BST)
一个有序数组通常称为lookup table。

- 输入一个有序数组
- 输出要查找的值及其对应的key
```java
BINARYSEARCH(S,k ,low ,high)
if low>high
    return no_such_key
else 
    mid = Math.floor((low+high)/2)
    if k = key(mid)
        return elem(mid)
    else if k<key(mid)
        return BINARYSEARCH(S, k, low, mid-1)
    else 
        return BINARYSEARCH(S, k, mid+1, high)
```
- key (i): the key at index i
- elem(i): the element at index i

lookup table 和 linked list比较
|Method|LinkedList|lookup table|
|------|----------|------------|
|查找元素|O(n)|O(logn)|
|插入元素(已知位置)|O(1)|O(n)|
|移除元素|O(n)|O(n)|
|ClosestKeyBefore|O(n)|O(logn)|

> 有没有一种数据结构可以既保证查找的效率又保证插入的效率？（综合lookup和linkedlist的优点）
>--- BST maybe possible.

- 二叉树的节点深度：节点的祖先的数量（排除节点自己）
- 二叉树的高度=该树最大的节点深度

二叉树的遍历方法
- 前序遍历(pre-order)
- 中序遍历(in-order)
- 后序遍历(post-order)

所有的BST的操作的时间复杂度都是O(h)，h表示树的高度。如果情况糟糕的话，h很有可能等于n（对于一个degenerate tree来说）。
如果BST不平衡的话，它最差的搜索时间可能是O(n)，这就失去了它的优点。

因此我们衍生出一种具有高度平衡的性质的树——AVL树

## AVL树
AVL树的性质：对于树T中的每个内部节点v，v的子节点之间的高度差最多是1。

存储n个节点的AVL树的高度是O(logn)

证明：一个高度为h的AVL树，令这棵树的内部节点最少有```n_h```个。最坏情况下，左树的高度为h-1，右树高度为h-2，且两颗子树都是AVL树。

所以```n_h = n_h-1 + n_h-2 + 1```，意思是整个树的节点是由左右两颗子树的节点加上根节点，因为```n_h-1>n_h-2```，所以```n_h>2*n_h-2 -> n_h>2^(h/2-1)```

- AVL树中的搜索操作，时间复杂度为O(logn)
- AVL中的插入和移除操作要小心（要使用rotation来保证height balance）

旋转这个操作太麻烦，在b站找到一个宝藏嚣张教程，记录一下。

宗旨：自下而上地找最小的一颗不平衡子树，如果向上找的节点太多，就选择离根节点最近的三个节点（包括根节点），将三个节点拿出来树状排序，插入原来的位置。剩下的元素根据二叉树的规则重新插入。

在下面这个AVL树中插入90
{{<mermaid>}}
flowchart TD
id1(50)-->id2(26)-->id3(21)
id2-->id4(30)
id1-->id5(66)-->id6(60)
id5-->id7(68)-->id8(67)
id7-->id9(70)
{{</mermaid>}}

插入后效果如下
{{<mermaid>}}
flowchart TD
id1(50)-->id2(26)-->id3(21)
id2-->id4(30)
id1-->id5(66)-->id6(60)
id5-->id7(68)-->id8(67)
id7-->id9(70)-->id10(90)
{{</mermaid>}}
很明显，这不是一颗AVL树。因此，从底部开始向上寻找最小的不平衡子树的根节点，发现是66。路径是90-->60，找到这条路径上距离66最近的三个节点（包括66本身），找到了66，68，70三个数。
对这三个数进行重新排列，如下图所示
{{<mermaid>}}
flowchart TD
id1(68)-->id2(70)
id1-->id3(66)
{{</mermaid>}}
排列后插入原来的位置，剩下的元素根据二叉树的规则重新插入，结果如下
{{<mermaid>}}
flowchart TD
id1(50)-->id2(26)-->id3(21)
id2-->id4(30)
id1-->id5(68)-->id6(66)
id5-->id7(70)-->id8(90)
id6-->id9(60)
id6-->id10(67)
{{</mermaid>}}
整套操作行云流水，十分清爽，爱了。删除也是同样的操作，删除后不平衡，找到最小不平衡树，然后重新排列。在AVL树中，所有的操作都可以在O(logn)内解决

## (2,4)树
(2,4)树的定义是这棵树的子节点，最少有两个，最多有四个。每个内部节点都包含1-3个键，这些键定义了存储在子树中的键的范围。这样的键要保证，比它最左边的子树中最大的键大，比最右边的子树中最小的键小。

(2,4)树的所有叶子节点都具备相同的深度。

- n个元素存储在(2,4)树中，其高度为O(logn)
- 拆分，转移和融合操作花费O(1)的时间
- 搜索，插入和删除元素需要访问树中O(logn)个节点。

# 排序-Sorting（W3）

排序问题，给一个集合C，包含n个元素，将C中的元素以升序方式重新排列。

排序通常是解决问题过程中的一个子例程。也就是说，想要实现算法的良好性能，高效的排序是很有必要的。

## Priority Queues
优先队列是一个存储元素的容器，每个元素都有对应的key。

优先队列的基本方法：
- insertItem(k, e)
- removeMin()
- minElement()
- minKey()

使用优先队列对一个集合C进行排序分为以下两个步骤
- 首先使用insertItem(k, e)，将C中的元素都放在优先队列P中。
- 使用removeMin()方法以升序方式从P中提取元素。

## 堆
堆是一种完全二叉树，即除了最后一层外，其它层都是满的，最后一层从左到右填满。n个元素的高度的是O(logn)

堆是有效的优先队列的实现，在插入元素和删除元素方面，堆允许在log时间内插入和删除元素。

在堆中，元素和键都被存在二叉树中。子节点中元素的键要大于等于其父节点中的键（堆序性-最小堆）

### 堆插入
堆中的插入操作，需要维护堆序性
- 将要插入的元素放在堆的底部（最后一个叶子节点的右侧）
- 比较该元素与其父节点的值，如果该元素的值小于（最小堆）其父节点的值，则交换这两个节点，然后继续向上比较（这个过程和bubble类似），直到满足堆序性为止。
- 插入操作完成后，堆中会多出一个元素，需要将堆的大小加 1。（堆的大小=堆中元素数量）
### 堆删除
堆中的删除操作，同样需要维护堆序性
- 取出堆顶元素
- 将最后一个叶子节点的值赋给堆顶元素。将最后一个叶子节点的值放到堆顶，相当于将堆顶元素删除，同时保证了堆仍然是一棵完全二叉树。
- 对新的堆顶元素进行下滤操作。下滤的过程类似于插入操作，将新的堆顶元素与它的子节点比较，如果子节点中有比它更小的，则交换位置，直到找不到比它小的为止。

|Operation|time|
|---------|----|
|size,isEmpty|O(1)|
|minElement,minKey|O(1)|
|insertItem|O(logn)|
|removeMin|O(logn|
### 堆排序
- 从下到上构造一个有n个元素的堆，时间复杂度为O(nlogn)
- 升序提取n个元素的时间复杂度为O(nlogn)

## 分治（Divide and Conquer）
顾名思义了，把一个大问题拆分，解决子问题后，再进行合并。（Divide-Recur-Conquer）

### 归并排序（MergeSort）
分治的经典例子，mergesort

对mergesort的divide部分，很好理解，但是到了merge部分就有些懵懂，因为有些课程省略了步骤，现在记录一下详细步骤。

假设有合并到了最后一步，现在有两个数组arr1和arr2
```java
arr1 = [2, 5, 7, 8]
arr2 = [1, 3, 6, 9]
```
我们要将它们合并成一个有序数组。首先，我们需要开辟一个长度为```len(arr1) + len(arr2)```的临时数组```temp```

接下来，需要设置两个指针```i```和```j```，分别指向两个数组的第一个元素，用于比较两个数组中的元素。还需要一个指针```k```，指向临时数组的第一个位置，用于存储排序后的元素。

**时间复杂度分析**
n个元素进行mergesort的时间复杂度为O(nlogn)

将mergesort的过程理解为二叉树，那么这颗二叉树的高度为O(logn)。这颗二叉树中每个子节点的复杂度为O(n)，因为要进行排序，最坏情况下，每个元素都会被访问一次。因此时间复杂度为O(nlogn)。空间复杂度为O(n)，因为需要另开辟一个长度为n的数组，存储排序好的数据。

### Counting inversions
长话短说，一组序列，有一对数i和j，都有i<j, 而且a[i]>a[j]，则称(i, j)是一个逆序对，Counting inversions就是一种计算逆序对数量的算法。

最笨的解决办法：找出所有数对并一个一个查看。这样做的时间复杂度是O(n^2)，太贵，做不起。

>使用分治，可以把时间复杂度压缩到O(nlogn)

具体做法
- 将一个序列按照中间位置分为左右两个子序列，递归地对左右两个子序列进行排序，并计算它们内部的逆序对数。
- 将左右两个子序列合并为一个有序的序列，同时计算左右两个子序列之间的逆序对数。
- 返回左右两个子序列内部的逆序对数、左右两个子序列之间的逆序对数以及合并后的有序序列。
- 逆序对数=两个子序列内部的逆序对数 + 左右两个子序列之间的逆序对数

时间复杂度分析
- 因为需要遍历两个子序列中的所有元素，因此复杂度是O(n)，n是序列中元素的数量。
- 由于每次递归的时候，问题规模减半，因此归并排序需要递归 logn 层
- 每层的复杂度是O(n)，因此归并排序时间复杂度是O(nlogn)

### 快排（QuickSort）
快排也是分治算法的一种，但是这种排序方法不同于归并排序。

**基本思想**：随机选择一个基准元素(pivot element)，然后将数组分为两个子序列，小于基准元素的放在左边，大于基准元素的放在右边，然后递归地对两部分排序，知道序列变得有序。

具体过程
- 选择一个基准元素（pivot），可以选择第一个元素、最后一个元素、中间的元素或者随机选择。
- 从序列的两端开始向中间扫描，左端找到一个比基准元素大的数，右端找到一个比基准元素小的数，交换这两个数的位置。
- 继续扫描，直到左右两个端点相遇。此时，所有比基准元素小的数都在基准元素的左边，比基准元素大的数都在基准元素的右边。
- 递归地对左右两个子序列进行快速排序。
- 当序列中只剩下一个元素时，排序结束。

时间复杂度分析
最坏情况下，每次划分都只能将序列分成一个元素和 n - 1 个元素两部分，这种情况下递归树的深度为 n，每层的时间复杂度是 O(n)（因为需要遍历所有 n 个元素进行比较）。因此，最坏情况下的时间复杂度为 O(n^2)。

在最好情况下，每次划分都将序列分成长度相等的两部分，这种情况下递归树的深度为 log(n)，每层的时间复杂度是 O(n)。因此，最好情况下的时间复杂度为 O(n log n)。

**如何避免worst case?**
随机选择pivot。随即快排的期望运行时间是O(nlogn)

如果分割的两部分的长度都不大于序列长度的3/4，则这样的pivot就是好的随机pivot。所以成功选择一个好的随机pivot的概率是1/2

## 线性时间排序（Bucket Sorting)
桶排序就是将数据分到不同的桶里，然后对每个桶中的数据进行排序，最后把所有桶中的数据合并起来得到有序序列

具体过程
- 将待排序的数据分配到不同的桶中。
- 对每个桶中的数据进行排序，可以选择任意一种排序算法，比如插入排序、归并排序等。
- 将各个桶中的数据按照顺序合并起来，得到有序序列。

桶排序适用于数据分布比较均匀的场景，如果数据分布不均匀，有些桶的数据量会比较大，就会影响桶排序的效率。比如对成绩进行排序，可以将分数分为 0-59、60-69、70-79、80-89、90-100 等五个区间，分别放到对应的桶中进行排序。

## 基数排序（Radix Sorting）
这是一种非比较排序算法，它是根据每个位的值来进行排序的。
在每一列上进行桶排序，然后逐列进行排序。可以将待排序的数据按照位数的不同，将其分配到不同的桶中进行排序，最后将所有桶中的数据按顺序合并起来。

### 时间复杂度分析
基数排序的时间复杂度取决于每次排序的子排序算法
- 如果使用插入排序作为子排序算法，基数排序的时间复杂度为 O(d*(n+k))，其中 d 表示待排序数据的位数，n 表示待排序数据的个数，k 表示桶的个数。
- 如果使用quicksort或mergesort作为子排序算法，基数排序的时间复杂度可以降低到 O(d*n)，但是空间复杂度会略有增加。

# 细说分治（W4）
